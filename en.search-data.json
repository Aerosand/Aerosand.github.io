{"/about/":{"data":{"":"This is a space for sharing and discussion on numerical calculation, CFD, OpenFOAM and more.\nnight test"},"title":"About"},"/news/":{"data":{"":" RSS Feed "},"title":"News"},"/ofs/":{"data":{"":"👋 Hello! Welcome to the OpenFOAM Sharing documentation!!!"},"title":"OpenFOAm Sharing"},"/ofs/ofsb/":{"data":{"":"Hugo Shortcodes are simple snippets inside your content files calling built-in or custom templates.\nHextra provides a collection of beautiful shortcodes to enhance your content.\nCallout Cards Details FileTree Icon Steps Tabs Additional shortcodes provided by Hugo and Hextra:\nJupyter Notebook alpha Others "},"title":"ofsb"},"/ofs/ofsp/":{"data":{"":"下面开始本系列的讨论。\n01_introduction custom tag "},"title":"ofsp"},"/ofs/ofsp/01_introduction/":{"data":{"":" Important\n访问 https://aerosand.cc 以获取最近更新。","1前置#1.前置":"本系列旨在帮助读者衔接“CFD 理论”和“OpenFOAM 入门实践”两个部分。\nWarning\n建议先学习计算流体力学基础以及有限体积法，之后再开始本系列的学习。","2介绍#2.介绍":"OpenFOAM 是什么呢？引用 wiki 解释如下\nOpenFOAM (for “Open-source Field Operation And Manipulation”) is a C++ toolbox for the development of customized numerical solvers, and pre-/post-processing utilities for the solution of continuum mechanics problems, most prominently including computational fluid dynamics (CFD).\n所以我们可以使用 OpenFOAM 来构建基于 C++ 的实现 CFD 等理论的求解器应用。","3环境和工具#3.环境和工具":"鉴于 OpenFOAM 的使用环境，我们选择在 ubuntu 24.04 系统环境中，基于 OpenFOAM 2406 版本进行开发讨论，方便起见使用 vscode 工具。\nCaution\nopenfoam.com 的版本变化较小，较新的版本均适合本系列讨论使用 openfoam.org 的版本架构大改，暂不推荐入门 ","3路线#3.路线":"我们从简单的 C++ 程序实现开始，简单了解编译原理，通过 makefile 逐渐掌控我们的项目，过渡到了解 OpenFOAM 的 make 实现方式，然后认识 OpenFOAM 的基本程序，然后逐渐深入了解 OpenFOAM 的求解器应用细节。\n编译原理 C++ 程序的编译 makefile 管理程序编译 wmake 管理程序编译 OpenFOAM 应用构建 数据交互 输入输出 命令行参数 基础类 时间 网格 场 求解器 开发库 第一个求解器 算法初见 SIMPLE \u0026 PISO \u0026 PIMPLE 算法 SIMPLE 求解器 Note\n每个部分都会有详细的代码和操作解释。","4建议#4.建议":" Tip\n建议读者动手跟随讨论编程操作 "},"title":"01_introduction"},"/ofs/ofsp/02_helloworld/":{"data":{"":"","1-开始#1. 开始":"","2-项目#2. 项目":"","3-预处理#3. 预处理":"1. 开始 Note\n对于 OpenFOAM 来说，不管是求解器还是算例，放在任何一个文件夹都可以。放在 $FOAM_RUN 路径下也是为了方便管理。\n我们约定\nuserPath/：用户指定路径 该路径下再新建例如 userPath/ofsp/ 文件夹，ofsp/ 下再新建各个子项目\n例如，\n终端输入命令，新建总项目文件夹\nterminalmkdir /userPath/ofsp ofsp 即 OpenFoam sharing programming 的缩写\n我们可以将 ofsp 设置为快捷命令，终端输入 ofsp 后可以直接跳转到项目文件夹下。\n终端输入命令，打开 bashrc 文件\nterminalgedit ~/.bashrc 在 bashrc 文件末尾添加一下语句\nbashrcalias ofsp='cd /userPath/ofsp' alias ofss='cd /userPath/ofss' 终端输入命令，使快捷命令生效\nterminalsource ~/.bashrc 2. 项目 通过终端新建本文子项目的文件夹\n终端输入命令\nterminalofsp mkdir ofsp_021_helloWorld code ofsp_021_helloWorld 通过 vscode 打开项目后，可以使用 ctrl + ~ 唤出 vscode 的终端控制台，快捷进行命令操作。\n终端输入命令，新建项目下文件并空白保存\nterminalcode main.cpp Aerosand.cpp Aerosand.h 终端输入 tree 命令，查看文件树状结构\nterminaltree . ├── Aerosand.cpp ├── Aerosand.h └── main.cpp Tip\n如果无法使用 tree 命令，请按照终端提示安装 tree 即可\n我们分别写入代码，内容如下\n类的声明 Class Aerosand.h 如下\nAerosand.h#pragma once class Aerosand { public: void setLocalTime(double t); double getLocalTime() const; private: double localTime_; }; Tip\n这里尽量贴近 OpenFOAM 的代码风格，比如函数名和变量采用驼峰命名，私有成员变量名称尾缀下划线等。\n类的定义 Aerosand.cpp 如下\nAerosand.cpp#include \"Aerosand.h\" void Aerosand::setLocalTime(double t) { localTime_ = t; } double Aerosand::getLocalTime() const { return localTime_; } 主源码 main.cpp 如下\nmain.cpp#include \u003ciostream\u003e #include \"Aerosand.h\" using namespace std; int main() { int a = 1; double pi = 3.1415926; cout \u003c\u003c \"Hi, OpenFOAM!\" \u003c\u003c \" Here we are.\" \u003c\u003c endl; cout \u003c\u003c a \u003c\u003c \" + \" \u003c\u003c pi \u003c\u003c \" = \" \u003c\u003c a + pi \u003c\u003c endl; cout \u003c\u003c a \u003c\u003c \" * \" \u003c\u003c pi \u003c\u003c \" = \" \u003c\u003c a * pi \u003c\u003c endl; Aerosand mySolver; mySolver.setLocalTime(0.2); cout \u003c\u003c \"\\nCurrent time step is : \" \u003c\u003c mySolver.getLocalTime() \u003c\u003c endl; return 0; } 虽然我们笼统的把代码到程序的整个过程称为“编译”，实际上，在 Linux 系统下，C++ 程序的“编译”过程分为四个过程。\nflowchart LR 预处理 --\u003e 编译 --\u003e 汇编 --\u003e 链接 Warning\n本文后续讨论的终端指令运行路径均留在 ofsp/ofsp_021_helloWorld/ 不变\n3. 预处理 预处理 Preprocessing 是编译过程的第一阶段，发生在真实编译（生成目标代码）之前。它由预处理器 Preprocessor 负责处理源代码中以 # 开头的指令，这些指令也被称为预处理指令。\n比如，#include 将提示把另一个文件的内容插入到当前位置，#define 将提示把宏定义替换到此处等等。\n生成。\n终端输入命令，执行预处理\nterminalg++ -E Aerosand.cpp -o Aerosand.i g++ -E main.cpp -o main.i Tip\ng++ 的 -E 标识预处理器进行预处理 g++ 的 -o （小写）标识指定生成的文件 在 Linux 系统下生成两个新文件\nAerosand.i main.i 后缀 .i 表示中间预处理输出文件 intermediate preprocessing output。","4-编译#4. 编译":"编译 Compile 是编译器 Compiler 把预处理后的源代码（.i 或 .i 文件）转换成汇编代码（.s 文件）的过程。\n编译器将会对已经展开（头文件、宏等）的源代码进行语法分析、语义分析、优化等工作，最终生成会变代码。\n终端输入命令，执行编译\nterminalg++ -S Aerosand.i -o Aerosand.s g++ -S main.i -o main.s Tip\ng++ 的 -S 标识指定编译器进行编译（大写 S ）\n在 Linux 系统下生成两个新文件\nAerosand.s main.s 后缀 .s（小写）表示汇编语言形式的源文件 source code written in assembly。","5-汇编#5. 汇编":"汇编 Assemble 是指汇编器 Assembler 将后缀 .s 表示的汇编语言形式的源文件转换成机器指令 Machine code，输出为目标文件 Object file的过程。\n汇编器将上一步的文件转换成人类可读的汇编语言，最终生成的与机器平台相关的二进制文件，不能直接运行，需要进一步处理。\n终端输入命令，执行汇编\nterminalg++ -c Aerosand.s -o Aerosand.o g++ -c main.s -o main.o Tip\ng++ 的 -c （小写）标识指定汇编器进行汇编\n在 Linux 系统下生成两个新文件\nAerosand.o main.o 后缀 .o（小写）表示目标文件 object file。","6-链接#6. 链接":"链接 Link 是链接器 Linker 把多个目标文件和系统库文件组合成一个完整可执行程序的过程。\n目标文件虽然包含机器指令，但仍然不是完整程序，链接器将找到其中函数调用涉及到“外部符号”的引用。\n终端输入命令，执行链接\nterminalg++ Aerosand.o main.o -o main.out 在 Linux 系统下最终生成一个可执行的新文件\nmain.out 这里的后缀 .out 并不重要，不加任何后缀也可以。\n终端输入 ./main.out 命令，运行该程序\nterminal./main.out Hi, OpenFOAM! Here we are. 1 + 3.14159 = 4.14159 1 * 3.14159 = 3.14159 Current time step is : 0.2 可以看到程序已经正常运行，得到了正确的结果。","7-动态库#7. 动态库":"即使上面已经顺利完成了程序的编译和运行，我们仍然要讨论多一些。\n当项目中有大量类的时候，我们希望某些类能固定下来提供某种“方法”，这种“方法”就形成一个可以重复使用的库 Library。由于库本身已经经过了完整的编译流程，当其他项目使用这个库的时候，库本身无需再次“预处理”，“编译”以及“汇编”，仅仅和这个项目链接即可。\n因为静态库开销大，浪费空间，更新维护困难，所以 OpenFOAM 大量使用动态库，我们这里也只以动态库为例。\n动态库在程序编译时并不链接到目标代码，而仅仅在程序运行时才被链接载入。不同的程序如果调用相同的库，那么内存里只需要一份该动态库的可共享实例，这样就大大减少了空间浪费。此外，因为动态库仅在程序运行时才被链接载入，所以库的单独维护更新也十分方便。\n编译器可以对汇编后的 .o 目标文件进行整理形成动态库，在 Linux 系统下生成 .so 文件。\n终端输入命令，执行生成动态库\nterminalg++ -shared -fPIC Aerosand.o -o libAerosand.so Tip\ng++ 的 -shared 标识指定生成动态链接库 g++ 的 -fPIC 标识指定创建与地址无关的编译程序，f 即 file，PIC 即 position independent code 动态库文件以 lib 开头 在 Linux 系统下生成一个可链接的动态库文件\nlibAerosand.so 后缀 .so 表示共享目标 shared object。","8-链接动态库#8. 链接动态库":"我们并不采用上面的链接方式，而是采用链接动态库的方式编译程序。\n终端输入指令，删除上一步的编译结果\nterminalrm main.out "},"title":"02_helloWorld"},"/ofs/ofss/":{"data":{"":"Hugo Shortcodes are simple snippets inside your content files calling built-in or custom templates.\nHextra provides a collection of beautiful shortcodes to enhance your content.\nCallout Cards Details FileTree Icon Steps Tabs Additional shortcodes provided by Hugo and Hextra:\nJupyter Notebook alpha Others "},"title":"ofss"}}