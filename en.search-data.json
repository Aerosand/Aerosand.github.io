{"/about/":{"data":{"":"This is a space for sharing and discussion on numerical calculation, CFD, OpenFOAM and more.\nnight test"},"title":"About"},"/news/":{"data":{"":"\rRSS Feed "},"title":"News"},"/ofs/":{"data":{"":"👋 Hello! Welcome to the OpenFOAM Sharing documentation!!!"},"title":"OpenFOAm Sharing"},"/ofs/ofsb/":{"data":{"":"Hugo Shortcodes are simple snippets inside your content files calling built-in or custom templates.\nHextra provides a collection of beautiful shortcodes to enhance your content.\nCallout\rCards\rDetails\rFileTree\rIcon\rSteps\rTabs\rAdditional shortcodes provided by Hugo and Hextra:\nJupyter Notebook alpha Others"},"title":"ofsb"},"/ofs/ofsp/":{"data":{"":"下面开始本系列的讨论。\n01_introduction start "},"title":"ofsp"},"/ofs/ofsp/01_introduction/":{"data":{"":"","1前置#1.前置":"","2介绍#2.介绍":"","3环境和工具#3.环境和工具":"","3路线#3.路线":"","4建议#4.建议":" Important\n访问 https://aerosand.cc 以获取最近更新。\n1.前置 本系列旨在帮助读者衔接“CFD 理论”和“OpenFOAM 入门实践”两个部分。\nWarning\n建议先学习计算流体力学基础以及有限体积法，之后再开始本系列的学习。\n2.介绍 OpenFOAM 是什么呢？引用 wiki 解释如下\nOpenFOAM (for “Open-source Field Operation And Manipulation”) is a C++ toolbox for the development of customized numerical solvers, and pre-/post-processing utilities for the solution of continuum mechanics problems, most prominently including computational fluid dynamics (CFD).\n所以我们可以使用 OpenFOAM 来构建基于 C++ 的实现 CFD 等理论的求解器应用。\n3.路线 我们从简单的 C++ 程序实现开始，简单了解编译原理，通过 make 逐渐掌控我们的项目，过渡到了解 OpenFOAM 的 wmake 实现方式，然后认识 OpenFOAM 的基本程序，然后逐渐深入了解 OpenFOAM 的求解器应用细节。\n编译原理 C++ 程序的编译 make 管理程序编译 wmake 管理程序编译 OpenFOAM 应用构建 数据交互 输入输出 命令行参数 基础类 时间 网格 场 求解器 开发库 第一个求解器 算法初见 SIMPLE \u0026 PISO \u0026 PIMPLE 算法 SIMPLE 求解器 Note\n每个部分都会有详细的代码和操作解释。\n3.环境和工具 鉴于 OpenFOAM 的使用环境，我们选择在 ubuntu 24.04 系统环境中，基于 OpenFOAM 2406 版本进行开发讨论，方便起见使用 vscode 工具。\nCaution\nopenfoam.com 的版本变化较小，较新的版本均适合本系列讨论使用 openfoam.org 的版本架构大改，暂不推荐入门 4.建议 Tip\n建议读者动手跟随讨论编程操作 "},"title":"01_introduction"},"/ofs/ofsp/02_helloworld/":{"data":{"":"","1-开始#1. 开始":"","2-项目#2. 项目":"","3-预处理#3. 预处理":"","4-编译#4. 编译":"","5-汇编#5. 汇编":"","6-链接#6. 链接":"","7-动态库#7. 动态库":"","8-链接动态库#8. 链接动态库":"1. 开始 Note\n对于 OpenFOAM 来说，不管是求解器还是算例，放在任何一个文件夹都可以。放在 $FOAM_RUN 路径下也是为了方便管理。\n我们约定\nuserPath/：用户指定路径 该路径下再新建例如 userPath/ofsp/ 文件夹，ofsp/ 下再新建各个子项目\n例如，\n终端输入命令，新建总项目文件夹\nterminalmkdir /userPath/ofsp ofsp 即 OpenFoam sharing programming 的缩写\n我们可以将 ofsp 设置为快捷命令，终端输入 ofsp 后可以直接跳转到项目文件夹下。\n终端输入命令，打开 bashrc 文件\nterminalgedit ~/.bashrc 在 bashrc 文件末尾添加一下语句\nbashrcalias ofsp='cd /userPath/ofsp' alias ofss='cd /userPath/ofss' 终端输入命令，使快捷命令生效\nterminalsource ~/.bashrc 2. 项目 通过终端新建本文的子项目的文件夹\n终端输入命令\nterminalofsp\rmkdir ofsp_021_helloWorld\rcode ofsp_021_helloWorld 通过 vscode 打开项目后，可以使用 ctrl + ~ 唤出 vscode 的终端控制台，快捷进行命令操作。\n终端输入命令，新建项目下文件并空白保存\nterminalcode main.cpp Aerosand.cpp Aerosand.h 终端输入 tree 命令，查看文件树状结构\nterminaltree\r.\r├── Aerosand.cpp\r├── Aerosand.h\r└── main.cpp Tip\n如果无法使用 tree 命令，请按照终端提示安装 tree 即可\n我们分别写入代码，内容如下\n类的声明 Class Aerosand.h 如下\n/Aerosand.h#pragma once class Aerosand { public: void setLocalTime(double t); double getLocalTime() const; private: double localTime_; }; Tip\n这里尽量贴近 OpenFOAM 的代码风格，比如函数名和变量采用驼峰命名，私有成员变量名称尾缀下划线等。\n类的定义 Aerosand.cpp 如下\n/Aerosand.cpp#include \"Aerosand.h\" void Aerosand::setLocalTime(double t) { localTime_ = t; } double Aerosand::getLocalTime() const { return localTime_; } 主源码 main.cpp 如下\n/main.cpp#include \u003ciostream\u003e #include \"Aerosand.h\" using namespace std; int main() { int a = 1; double pi = 3.1415926; cout \u003c\u003c \"Hi, OpenFOAM!\" \u003c\u003c \" Here we are.\" \u003c\u003c endl; cout \u003c\u003c a \u003c\u003c \" + \" \u003c\u003c pi \u003c\u003c \" = \" \u003c\u003c a + pi \u003c\u003c endl; cout \u003c\u003c a \u003c\u003c \" * \" \u003c\u003c pi \u003c\u003c \" = \" \u003c\u003c a * pi \u003c\u003c endl; Aerosand mySolver; mySolver.setLocalTime(0.2); cout \u003c\u003c \"\\nCurrent time step is : \" \u003c\u003c mySolver.getLocalTime() \u003c\u003c endl; return 0; } 虽然我们笼统的把代码到程序的整个过程称为“编译”，实际上，在 Linux 系统下，C++ 程序的“编译”过程分为四个过程。\nflowchart LR\r预处理 --\u003e 编译 --\u003e 汇编 --\u003e 链接 Warning\n本文后续讨论的终端指令运行路径均留在 ofsp/ofsp_021_helloWorld/ 不变\n3. 预处理 预处理 Preprocessing 是编译过程的第一阶段，发生在真实编译（生成目标代码）之前。它由预处理器 Preprocessor 负责处理源代码中以 # 开头的指令，这些指令也被称为预处理指令。\n比如，#include 将提示把另一个文件的内容插入到当前位置，#define 将提示把宏定义替换到此处等等。\n生成。\n终端输入命令，执行预处理\nterminalg++ -E Aerosand.cpp -o Aerosand.i g++ -E main.cpp -o main.i Tip\ng++ 的 -E 标识预处理器进行预处理 g++ 的 -o （小写）标识指定生成的文件 在 Linux 系统下生成两个新文件\nAerosand.i main.i 后缀 .i 表示中间预处理输出文件 intermediate preprocessing output。\n4. 编译 编译 Compile 是编译器 Compiler 把预处理后的源代码（.i 或 .i 文件）转换成汇编代码（.s 文件）的过程。\n编译器将会对已经展开（头文件、宏等）的源代码进行语法分析、语义分析、优化等工作，最终生成会变代码。\n终端输入命令，执行编译\nterminalg++ -S Aerosand.i -o Aerosand.s\rg++ -S main.i -o main.s Tip\ng++ 的 -S 标识指定编译器进行编译（大写 S ）\n在 Linux 系统下生成两个新文件\nAerosand.s main.s 后缀 .s（小写）表示汇编语言形式的源文件 source code written in assembly。\n5. 汇编 汇编 Assemble 是指汇编器 Assembler 将后缀 .s 表示的汇编语言形式的源文件转换成机器指令 Machine code，输出为目标文件 Object file的过程。\n汇编器将上一步的文件转换成人类可读的汇编语言，最终生成的与机器平台相关的二进制文件，不能直接运行，需要进一步处理。\n终端输入命令，执行汇编\nterminalg++ -c Aerosand.s -o Aerosand.o\rg++ -c main.s -o main.o Tip\ng++ 的 -c （小写）标识指定汇编器进行汇编\n在 Linux 系统下生成两个新文件\nAerosand.o main.o 后缀 .o（小写）表示目标文件 object file。\n6. 链接 链接 Link 是链接器 Linker 把多个目标文件和系统库文件组合成一个完整可执行程序的过程。\n目标文件虽然包含机器指令，但仍然不是完整程序，链接器将找到其中函数调用涉及到“外部符号”的引用，生成可执行的二进制文件。\n终端输入命令，执行链接\nterminalg++ Aerosand.o main.o -o main.out 在 Linux 系统下最终生成一个可执行的新文件\nmain.out 这里的后缀 .out 并不重要，不加任何后缀也可以。\n终端输入 ./main.out 命令，运行该程序\nterminal./main.out\rHi, OpenFOAM! Here we are.\r1 + 3.14159 = 4.14159\r1 * 3.14159 = 3.14159\rCurrent time step is : 0.2 可以看到程序已经正常运行，得到了正确的结果。\n7. 动态库 即使上面已经顺利完成了程序的编译和运行，我们仍然要讨论多一些。\n当项目中有大量类的时候，我们希望某些类能固定下来提供某种“方法”，这种“方法”就形成一个可以重复使用的库 Library。由于库本身已经经过了完整的编译流程，当其他项目使用这个库的时候，库本身无需再次“预处理”，“编译”以及“汇编”，仅仅和这个项目链接即可。\n因为静态库开销大，浪费空间，更新维护困难，所以 OpenFOAM 大量使用动态库，我们这里也只以动态库为例。\n动态库在程序编译时并不链接到目标代码，而仅仅在程序运行时才被链接载入。不同的程序如果调用相同的库，那么内存里只需要一份该动态库的可共享实例，这样就大大减少了空间浪费。此外，因为动态库仅在程序运行时才被链接载入，所以库的单独维护更新也十分方便。\n编译器可以对汇编后的 .o 目标文件进行整理形成动态库，在 Linux 系统下生成 .so 文件。\n终端输入命令，执行生成动态库\nterminalg++ -shared -fPIC Aerosand.o -o libAerosand.so Tip\ng++ 的 -shared 标识指定生成动态链接库 g++ 的 -fPIC 标识指定创建与地址无关的编译程序，f 即 file，PIC 即 position independent code 动态库文件以 lib 开头 在 Linux 系统下生成一个可链接的动态库文件\nlibAerosand.so 后缀 .so 表示共享目标 shared object。\n8. 链接动态库 我们并不采用上面的链接方式，而是采用链接动态库的方式编译程序。\n终端输入指令，删除上一步的编译结果\nterminalrm main.out 使用 echo 命令查看原本动态库链接路径，可以发现并不是项目本地路径。\n终端输入命令\nterminalecho $LD_LIBRARY_PATH 临时指定动态库路径为当前文件夹\n终端输入命令\nterminalexport LD_LIBRARY_PATH=.\recho $LD_LIBRARY_PATH Tip\n不要担心，临时指定不影响 OpenFOAM 动态库路径的环境配置\n终端输入命令，链接动态库生成可执行文件\nterminalg++ main.o -L. -lAerosand -o main Tip\ng++ 的 -L 标识指定的动态库的路径， 使用 -L. 表示动态库在当前路径 g++ 的 -l 标识指定的动态库的名称，使用时省略动态库的 lib 字段 如前所述，可执行程序的后缀在这里并不重要 在 Linux 系统下生成一个可执行程序\nmain Tip\n前文指定的动态库路径是临时的，如果重启计算机，想要再次运行 main 程序，必须要再次指定动态库路径 无论是把新开发库放在本项目路径下，或是其他任何路径下，任何位置的项目都可以链接使用这个动态库，只要指定正确的链接路径即可。这也是动态库“相对独立”“自由链接”的意义所在 总结整个过程如下\nflowchart TD\rmain.cpp --\u003e|预处理| main.i --\u003e|编译| main.s --\u003e|汇编| main.o --\u003e 等待链接\rAerosand.cpp --\u003e|预处理| Aerosand.i --\u003e|编译| Aerosand.s --\u003e|汇编| Aerosand.o --\u003e|动态库| Aerosand.so\r等待链接 --\u003e|链接| main\rAerosand.so --\u003e|链接| main 终端输入 ./main 命令，运行该程序\nterminal./main\rHi, OpenFOAM! Here we are.\r1 + 3.14159 = 4.14159\r1 * 3.14159 = 3.14159\rCurrent time step is : 0.2 可以看到程序已经正常运行，得到了正确的结果。"},"title":"02_helloWorld"},"/ofs/ofsp/03_make/":{"data":{"":" Note\n上一篇讨论的编译过程虽然清晰，但是一步一步的执行十分繁琐\n为了简化项目编译，以及兼顾理解编译细节，我们采用 make 工具来管理我们的开发项目。很多人也会使用 cmake 来构建项目，cmake 更加简洁高效，不过本质上也是基于 makefile 的。\n我们可以为项目提供 makefile 文件，在 makefile 中描述所有执行步骤。这样只需要简单执行 makefile 文件就可以编译整个项目，大大方便调试运行。此外，在之前的项目里，所有代码文件都放在一起，十分不方便，所以我们对代码进行架构管理。","1-项目#1. 项目":"终端输入命令，建立本文项目\nterminalofsp mkdir ofsp_031_make code ofsp_031_make 继续使用终端命令或者使用 vscode 界面创建其他文件，最终文件结构如下\nterminaltree . ├── Aerosand │ ├── Aerosand.cpp │ ├── Aerosand.h │ └── makefile ├── makefile └── ofsp_031_make.cpp Tip\n此时可以认为我们建立了一个库 Aerosand，其中包含一个同名类 Aerosand\n类 Aerosand 的声明 Aerosand.h，内容不变\n/Aersoand/Aerosand.h#pragma once class Aerosand { public: void setLocalTime(double t); double getLocalTime() const; private: double localTime_; }; 类 Aerosand 的定义 Aerosand.cpp，内容不变\n/Aerosand/Aerosand.cpp#include \"Aerosand.h\" void Aerosand::setLocalTime(double t) { localTime_ = t; } double Aerosand::getLocalTime() const { return localTime_; } 主源码 ofsp_031_make.cpp 需要修改头文件，其他内容不变\n/ofsp_031_make.cpp#include \u003ciostream\u003e #include \"Aerosand/Aerosand.h\" // 因为路径变化，需要修改此行 using namespace std; int main() { int a = 1; double pi = 3.1415926; cout \u003c\u003c \"Hi, OpenFOAM!\" \u003c\u003c \" Here we are.\" \u003c\u003c endl; cout \u003c\u003c a \u003c\u003c \" + \" \u003c\u003c pi \u003c\u003c \" = \" \u003c\u003c a + pi \u003c\u003c endl; cout \u003c\u003c a \u003c\u003c \" * \" \u003c\u003c pi \u003c\u003c \" = \" \u003c\u003c a * pi \u003c\u003c endl; Aerosand mySolver; mySolver.setLocalTime(0.2); cout \u003c\u003c \"\\nCurrent time step is : \" \u003c\u003c mySolver.getLocalTime() \u003c\u003c endl; return 0; } ","2-make#2. make":"自动化构建工具 make 可以根据 makefile 中的规则自动完成源代码的编译、链接过程。\nmakefile 文件的基本格式为\nmakefile\u003ctarget\u003e: \u003csupport\u003e \u003ccommand\u003e 基于前文对 C++ 项目编译原理的过程的讨论，我们可以为库 Aerosand 提供 makefile 文件，直白的给出编译规范\n文件内容如下\n/Aerosand/makefileAerosand.o: Aerosand.cpp g++ -c -fPIC Aerosand.cpp -o Aerosand.o libAerosand.so: Aerosand.o g++ -shared -fPIC Aerosand.o -o libAerosand.so "},"title":"03_make"},"/ofs/ofss/":{"data":{"":"Hugo Shortcodes are simple snippets inside your content files calling built-in or custom templates.\nHextra provides a collection of beautiful shortcodes to enhance your content.\nCallout\rCards\rDetails\rFileTree\rIcon\rSteps\rTabs\rAdditional shortcodes provided by Hugo and Hextra:\nJupyter Notebook alpha Others"},"title":"ofss"}}